# frozen_string_literal: true

require 'active_support/inflector'
require 'yaml'

require_relative './entry'
require_relative './entry_file'
require_relative './helpers'
require_relative '../lists/entry_file_ext'

module Codex
  class Task
    include Helpers

    using Lists::EntryFileExt

    attr_reader :output_path

    def initialize(glob_pattern, output_path)
      @glob_pattern = glob_pattern
      @output_path = output_path
    end

    def input_files
      Dir.glob(@glob_pattern)
    end

    def run
      puts "Generating codex file #{@output_path}..."

      entries = {}
      input_files.each do |path|
        entry = build_entry(path)
        next if entry.nil?
        raise "Duplicate ID value #{entry.id} found at #{entries[entry.id].path} and #{path}" if entries.key?(entry.id)

        entries[entry.id] = entry
      end
      check_contiguous_ids entries
      output_file entries
    end

    def build_entry(path)
      godot_path = path.gsub(%r{^\./?}, "res://")
      entry_file = EntryFile.new(path)

      case
      when entry_file.ignored?
        # Ignore, by definition. Do not warn, since we opted into
        # this behavior.
        nil
      when entry_file.id.nil?
        raise "No ID value at #{path}"
      else
        Entry.new(
          id: entry_file.id,
          path: godot_path,
          limited: !!entry_file.limited?,
          rarity: entry_file.rarity,
        )
      end
    end

    def class_name
      File.basename(@output_path, ".*").camelize
    end

    def check_contiguous_ids(entries_hash)
      max_id = entries_hash.keys.max
      missing_ids = 0.upto(max_id).filter { |id| !entries_hash.key?(id) }
      raise "ID values are not contiguous, missing values are #{missing_ids.join(', ')}" if missing_ids.any?
    end

    def id_lines(entries)
      entries.map { |entry| "#{entry.name} = #{entry.id}," }.join("\n")
    end

    def lookup_lines(entries)
      cases = entries.map { |entry| <<~MATCH }.join('').rstrip
        ID.#{entry.name}:
            return load("#{entry.path}") as GDScript
      MATCH
      <<~CODE
        match n:
        #{indent(cases, 4)}
            _:
                push_warning("Invalid ID value: %d" % n)
                return null
      CODE
    end

    def output_file(entries_hash)
      case File.extname(output_path).downcase
      when '.gd'
        output_gd_file entries_hash
      when '.yaml'
        output_yaml_file entries_hash
      else
        STDERR.puts "Invalid output file extension: #{output_path}"
      end
    end

    private def output_gd_file(entries_hash)
      sorted_entries = entries_hash.values.sort_by(&:id)
      max_id = sorted_entries.last.id
      File.open(@output_path, "w") { |f| f.write <<~CODE }
        ## THIS FILE WAS GENERATED BY AN AUTOMATED RUBY TASK!
        ## ANY MODIFICATIONS MADE TO THIS FILE MAY BE OVERWRITTEN!

        class_name #{class_name}
        extends Node

        enum ID {
        #{indent(id_lines(sorted_entries), 4)}
        }

        static func get_entity_script(n: int) -> GDScript:
        #{indent(lookup_lines(sorted_entries), 4)}

        static func get_entity(n: int):
            return get_entity_script(n).new()

        static func get_all_ids() -> Array:
            return range(#{max_id + 1})
      CODE
    end

    private def output_yaml_file(entries_hash)
      sorted_entries = entries_hash.values.sort_by(&:id)
      max_id = sorted_entries.last.id

      data = {
        "max_id" => max_id,
        "cards" => sorted_entries.map(&:to_h)
      }

      File.open(@output_path, "w") do |f|
        f.write <<~COMMENT
          ## THIS FILE WAS GENERATED BY AN AUTOMATED RUBY TASK!
          ## ANY MODIFICATIONS MADE TO THIS FILE MAY BE OVERWRITTEN!
        COMMENT
        f.write data.to_yaml
      end
    end
  end
end
